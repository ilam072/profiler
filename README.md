# Sum API Benchmark Project

## Описание проекта

Проект демонстрирует оптимизацию простого HTTP API для сложения чисел на Go.
Цель — показать разницу в производительности между базовой версией с JSON POST и оптимизированной версией с GET-параметрами, а также научиться собирать и анализировать профили CPU, памяти и execution trace.

**API позволяет:**

- Суммировать два числа через GET с query-параметрами

- Профилировать выполнение через pprof и анализировать trace

- Генерировать нагрузку для проверки производительности
---
## Профилирование API

### Доступные ручки pprof

| Ручка                             | Описание                       |
| --------------------------------- | ------------------------------ |
| `/debug/pprof/`                   | Список всех доступных профилей |
| `/debug/pprof/profile?seconds=30` | CPU-профиль за 30 секунд       |
| `/debug/pprof/heap`               | Профиль памяти (heap)          |
| `/debug/pprof/goroutine`          | Состояние всех горутин         |
| `/debug/pprof/block`              | Профили блокировок             |
| `/debug/pprof/threadcreate`       | Профили создания потоков       |
| `/debug/pprof/trace?seconds=5`    | Execution trace (5 секунд)     |

> Профили доступны после запуска сервера с импортом `_ "net/http/pprof"` и запуском сервера, например на `localhost:8080`.
---
### Создание нагрузки с помощью `hey`

1. Установить `hey`:

```bash
go install github.com/rakyll/hey@latest
```

2. Добавить путь к бинарнику в PATH

3. Запустить нагрузку на API:

```bash
hey -n 100000 -c 50 http://localhost:8080/sum2?a=1&b=2
```

* `-n 100000` — всего запросов
* `-c 50` — одновременных подключений

> После этого можно собирать профили CPU и памяти через pprof или trace, чтобы анализировать производительность.
---
## Версии

### 1. Старая версия (POST + JSON)

* Метод: **POST**
* Принимает JSON тело с полями `a` и `b`.
* Использует `json.Decoder` и `json.Encoder`.
* Создаёт объекты `Req` и `Resp` на каждый запрос.

### 2. Улучшенная версия (GET + query)

* Метод: **GET**
* Параметры `a` и `b` берутся из query-параметров.
* Нет JSON декодирования тела запроса.
* Ответ формируется напрямую через `json.Marshal`.
* Меньше лишних аллокаций и быстрее CPU-выполнение.
---
## Бенчмарки

Запуск (из корня проекта):

```bash
go test -bench=. -benchmem ./internal/rest > benchmarks/old.txt

go test -bench=. -benchmem ./internal/rest > benchmarks/new.txt

benchstat old.txt new.txt
```

### Результаты

| Метрика     | Старая версия (POST + JSON) | Улучшенная версия (GET + query) | Разница              |
| ----------- | --------------------------- | ------------------------------- | -------------------- |
| `ns/op`     | 3519 ns                     | 3038 ns                         | ~14% быстрее         |
| `B/op`      | 7109 B                      | 7013 B                          | немного меньше (~1%) |
| `allocs/op` | 27                          | 27                              | без изменений        |

---
## Вывод

* Улучшенная версия быстрее по CPU за счёт отказа от JSON-декодирования и создания лишних структур.
* Память немного экономится, хотя количество аллокаций остаётся прежним.
* Проект демонстрирует подход “до/после” оптимизации с сохранением совместимого формата ответа в JSON.
